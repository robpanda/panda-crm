/**
 * Project Expediting Workflow Triggers
 *
 * Handles automations for project expediting process:
 * - Flat Roof = Yes → creates case for Trevor (roof complexity review)
 * - Line Drop = Yes → creates case for Kevin Flores + sends SMS to homeowner
 * - Supplement Required + Supplement Holds Job → sets notInstallReady
 *
 * These replicate and enhance the Salesforce Project Expediting workflow.
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Bamboogli service URL for sending SMS
const BAMBOOGLI_SERVICE_URL = process.env.BAMBOOGLI_SERVICE_URL || 'http://bamboogli-service:3012';

// Assigned users for expediting cases
const EXPEDITING_USERS = {
  FLAT_ROOF: 'trevorjohnson@pandaexteriors.com',
  LINE_DROP: 'kevinflores@pandaexteriors.com',
  HOA: null, // HOA cases are assigned by the user creating them
};

// Case types and subjects
const CASE_TYPES = {
  FLAT_ROOF: 'Flat Roof Review',
  LINE_DROP: 'Line Drop Required',
  HOA: 'HOA Approval',
};

const CASE_SUBJECTS = {
  FLAT_ROOF: 'Flat Roof Review Required',
  LINE_DROP: 'Line Drop Coordination Required',
  HOA: 'HOA Approval Required',
};

// Line Drop SMS message for homeowner
const LINE_DROP_SMS_MESSAGE = `Hi! Your project requires an electrical line drop by your power company. You will need to contact your power company and schedule the line drop. Once your project reaches scheduling a member of our production team will reach out to let you know it's time to contact your power company to schedule the line drop and we will coordinate our install schedule around the dates you are given.`;

/**
 * Generate the next case number
 */
async function generateCaseNumber() {
  const lastCase = await prisma.case.findFirst({
    orderBy: { createdAt: 'desc' },
    select: { caseNumber: true },
  });

  let nextNumber = 1;
  if (lastCase?.caseNumber) {
    const match = lastCase.caseNumber.match(/CASE-(\d+)/);
    if (match) {
      nextNumber = parseInt(match[1]) + 1;
    }
  }
  return `CASE-${String(nextNumber).padStart(6, '0')}`;
}

/**
 * Helper: Get phone number from contact (priority: rileyNumber > mobilePhone > phone)
 */
function getPhoneNumber(contact) {
  if (!contact) return null;
  return contact.rileyNumber || contact.mobilePhone || contact.phone || null;
}

/**
 * Helper: Send SMS via Bamboogli service
 */
async function sendSms({ to, message, contactId, accountId, opportunityId }) {
  try {
    // Format phone number to E.164 if needed
    let formattedPhone = to;
    if (to && !to.startsWith('+')) {
      const digits = to.replace(/\D/g, '');
      if (digits.length === 10) {
        formattedPhone = `+1${digits}`;
      } else if (digits.length === 11 && digits.startsWith('1')) {
        formattedPhone = `+${digits}`;
      }
    }

    if (!formattedPhone) {
      console.warn('[Expediting Trigger] No phone number provided');
      return { success: false, error: 'No phone number provided' };
    }

    console.log(`[Expediting Trigger] Sending SMS to ${formattedPhone}`);

    const response = await fetch(`${BAMBOOGLI_SERVICE_URL}/api/messages/send`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        to: formattedPhone,
        body: message,
        channel: 'SMS',
        metadata: {
          contactId,
          accountId,
          opportunityId,
          triggeredBy: 'expeditingTriggers',
          autoGenerated: true,
          triggerType: 'LINE_DROP',
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('[Expediting Trigger] Failed to send SMS:', errorText);
      return { success: false, error: errorText };
    }

    const result = await response.json();
    console.log('[Expediting Trigger] SMS sent successfully:', result);

    // Log activity
    await prisma.activity.create({
      data: {
        type: 'SMS_SENT',
        subType: 'OUTBOUND',
        subject: 'Line Drop SMS Sent to Homeowner',
        body: message,
        status: 'COMPLETED',
        contactId,
        accountId,
        opportunityId,
        occurredAt: new Date(),
        metadata: {
          phone: formattedPhone,
          triggeredBy: 'expeditingTriggers',
          autoGenerated: true,
          triggerType: 'LINE_DROP',
        },
      },
    });

    return { success: true, result };
  } catch (error) {
    console.error('[Expediting Trigger] Error sending SMS:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get user by email for case assignment
 */
async function getUserByEmail(email) {
  try {
    const user = await prisma.user.findUnique({
      where: { email },
      select: { id: true, fullName: true, email: true },
    });
    return user;
  } catch (error) {
    console.error(`[Expediting Trigger] Error finding user by email ${email}:`, error);
    return null;
  }
}

/**
 * Create an expediting case
 */
async function createExpeditingCase(opportunityId, subject, description, type, assignToEmail, userId) {
  try {
    const opportunity = await prisma.opportunity.findUnique({
      where: { id: opportunityId },
      include: {
        account: true,
        owner: true,
      },
    });

    if (!opportunity) {
      throw new Error(`Opportunity not found: ${opportunityId}`);
    }

    // Check if a similar case already exists and is open
    const existingCase = await prisma.case.findFirst({
      where: {
        accountId: opportunity.accountId,
        subject: subject,
        status: { in: ['NEW', 'WORKING', 'ESCALATED'] },
      },
    });

    if (existingCase) {
      console.log(`[Expediting Trigger] Case already exists for ${subject}: ${existingCase.id}`);
      return { existing: true, case: existingCase };
    }

    // Get assigned user
    const assignedUser = await getUserByEmail(assignToEmail);

    const caseNumber = await generateCaseNumber();

    const caseData = {
      caseNumber,
      subject,
      description: `${description}\n\nOpportunity: ${opportunity.name}\nJob ID: ${opportunity.jobId || 'N/A'}\nAccount: ${opportunity.account?.name || 'N/A'}\n\nThis case was auto-generated by the project expediting workflow.`,
      accountId: opportunity.accountId,
      priority: 'HIGH',
      type: type,
      status: 'NEW',
      origin: 'WORKFLOW',
    };

    const newCase = await prisma.case.create({
      data: caseData,
    });

    console.log(`[Expediting Trigger] Created case: ${newCase.caseNumber} - ${subject}`);
    if (assignedUser) {
      console.log(`[Expediting Trigger] Case should be assigned to: ${assignedUser.fullName || assignedUser.email}`);
    }

    // Create activity log
    await prisma.activity.create({
      data: {
        type: 'CASE_CREATED',
        subject: `Case Created: ${subject}`,
        body: `Auto-generated case for project expediting.\nCase Number: ${caseNumber}\nAssigned To: ${assignedUser?.fullName || assignToEmail}`,
        status: 'COMPLETED',
        opportunityId: opportunityId,
        accountId: opportunity.accountId,
        userId: userId,
        occurredAt: new Date(),
        metadata: {
          triggeredBy: 'expediting_workflow',
          autoGenerated: true,
          caseId: newCase.id,
          caseNumber: caseNumber,
          triggerType: type,
          assignedToEmail: assignToEmail,
          assignedToId: assignedUser?.id,
        },
      },
    });

    // Create attention item for assigned user
    if (assignedUser) {
      await prisma.attentionItem.create({
        data: {
          type: 'CASE',
          relatedId: newCase.id,
          assignedToId: assignedUser.id,
          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours from now
          priority: 'HIGH',
          title: subject,
          description: `New case requires attention: ${caseNumber}`,
        },
      });
      console.log(`[Expediting Trigger] Created attention item for ${assignedUser.email}`);
    }

    return { existing: false, case: newCase, assignedUser };
  } catch (error) {
    console.error(`[Expediting Trigger] Failed to create case:`, error);
    throw error;
  }
}

// ============================================================================
// TRIGGER 1: Flat Roof
// When flatRoof is set to true, create a case for Trevor
// ============================================================================

/**
 * Trigger: Flat Roof Detected
 * When flatRoof is set to true, create a case for Trevor Johnson
 */
export async function onFlatRoofDetected(opportunityId, userId) {
  console.log(`[Expediting Trigger] Flat Roof Detected for Opportunity: ${opportunityId}`);

  const result = {
    case: null,
    error: null,
  };

  try {
    const caseResult = await createExpeditingCase(
      opportunityId,
      CASE_SUBJECTS.FLAT_ROOF,
      'This job has been identified as having a flat roof and requires review by the flat roof specialist before proceeding with installation planning.',
      CASE_TYPES.FLAT_ROOF,
      EXPEDITING_USERS.FLAT_ROOF,
      userId
    );

    result.case = caseResult.case;
    result.wasExisting = caseResult.existing;
    result.assignedUser = caseResult.assignedUser;

    return result;
  } catch (error) {
    console.error('[Expediting Trigger] onFlatRoofDetected failed:', error);
    result.error = error.message;
    return result;
  }
}

// ============================================================================
// TRIGGER 2: Line Drop
// When lineDrop is set to true:
// 1. Create a case for Kevin Flores
// 2. Send SMS to homeowner explaining the line drop process
// ============================================================================

/**
 * Trigger: Line Drop Required
 * When lineDrop is set to true:
 * - Create a case for Kevin Flores
 * - Send SMS to homeowner with line drop instructions
 */
export async function onLineDropRequired(opportunityId, userId) {
  console.log(`[Expediting Trigger] Line Drop Required for Opportunity: ${opportunityId}`);

  const result = {
    case: null,
    sms: null,
    error: null,
  };

  try {
    // 1. Create case for Kevin Flores
    const caseResult = await createExpeditingCase(
      opportunityId,
      CASE_SUBJECTS.LINE_DROP,
      'This job requires an electrical line drop. Coordinate with the homeowner and power company to schedule the line drop before installation can proceed.',
      CASE_TYPES.LINE_DROP,
      EXPEDITING_USERS.LINE_DROP,
      userId
    );

    result.case = caseResult.case;
    result.wasExisting = caseResult.existing;
    result.assignedUser = caseResult.assignedUser;

    // 2. Send SMS to homeowner
    const opportunity = await prisma.opportunity.findUnique({
      where: { id: opportunityId },
      include: {
        account: {
          include: {
            contacts: {
              where: { isPrimary: true },
              take: 1,
            },
          },
        },
        contact: true,
      },
    });

    // Get primary contact (from opportunity contact or account primary contact)
    const homeownerContact = opportunity?.contact || opportunity?.account?.contacts?.[0];

    if (homeownerContact) {
      const phoneNumber = getPhoneNumber(homeownerContact);
      if (phoneNumber) {
        // Personalize message with homeowner name if available
        const firstName = homeownerContact.firstName || '';
        const personalizedMessage = firstName
          ? `Hi ${firstName}! ${LINE_DROP_SMS_MESSAGE.replace('Hi!', '').trim()}`
          : LINE_DROP_SMS_MESSAGE;

        const smsResult = await sendSms({
          to: phoneNumber,
          message: personalizedMessage,
          contactId: homeownerContact.id,
          accountId: opportunity.accountId,
          opportunityId: opportunityId,
        });

        result.sms = smsResult;
      } else {
        console.log('[Expediting Trigger] No phone number for homeowner, SMS not sent');
        result.sms = { success: false, error: 'No phone number available' };
      }
    } else {
      console.log('[Expediting Trigger] No primary contact found, SMS not sent');
      result.sms = { success: false, error: 'No primary contact found' };
    }

    return result;
  } catch (error) {
    console.error('[Expediting Trigger] onLineDropRequired failed:', error);
    result.error = error.message;
    return result;
  }
}

// ============================================================================
// TRIGGER 3: Supplement Holds Job
// When supplementRequired=true AND supplementHoldsJob=true:
// Set notInstallReady=true with reason
// ============================================================================

/**
 * Trigger: Supplement Holds Job
 * When both supplementRequired and supplementHoldsJob are true,
 * automatically set notInstallReady to true
 */
export async function onSupplementHoldsJob(opportunityId, userId) {
  console.log(`[Expediting Trigger] Supplement Holds Job for Opportunity: ${opportunityId}`);

  const result = {
    updated: false,
    error: null,
  };

  try {
    const opportunity = await prisma.opportunity.findUnique({
      where: { id: opportunityId },
      select: {
        id: true,
        supplementRequired: true,
        supplementHoldsJob: true,
        notInstallReady: true,
        notInstallReadyNotes: true,
      },
    });

    if (!opportunity) {
      throw new Error(`Opportunity not found: ${opportunityId}`);
    }

    // Only proceed if supplement holds job
    if (opportunity.supplementRequired && opportunity.supplementHoldsJob) {
      // Set not install ready
      const existingNotes = opportunity.notInstallReadyNotes || '';
      const supplementNote = 'Supplement required - job on hold pending supplement approval.';

      // Don't duplicate the note
      const newNotes = existingNotes.includes(supplementNote)
        ? existingNotes
        : existingNotes
        ? `${existingNotes}\n${supplementNote}`
        : supplementNote;

      await prisma.opportunity.update({
        where: { id: opportunityId },
        data: {
          notInstallReady: true,
          notInstallReadyNotes: newNotes,
        },
      });

      console.log(`[Expediting Trigger] Set notInstallReady=true for ${opportunityId}`);

      // Create activity log
      await prisma.activity.create({
        data: {
          type: 'STATUS_CHANGE',
          subject: 'Job Set to Not Install Ready',
          body: 'Job automatically set to Not Install Ready due to supplement hold.',
          status: 'COMPLETED',
          opportunityId: opportunityId,
          userId: userId,
          occurredAt: new Date(),
          metadata: {
            triggeredBy: 'expediting_workflow',
            autoGenerated: true,
            reason: 'supplement_holds_job',
          },
        },
      });

      result.updated = true;
    }

    return result;
  } catch (error) {
    console.error('[Expediting Trigger] onSupplementHoldsJob failed:', error);
    result.error = error.message;
    return result;
  }
}

// ============================================================================
// TRIGGER 4: HOA Required
// When hoaRequired is set to 'yes', auto-create HOA case (optional)
// The frontend ExpediterChecklist handles manual case creation with popup
// ============================================================================

/**
 * Trigger: HOA Required
 * When hoaRequired is set to 'yes', optionally create an HOA case
 * Note: The primary case creation is handled via the frontend modal,
 * but this provides an automated fallback if no case exists
 */
export async function onHoaRequired(opportunityId, userId, autoCreateCase = false) {
  console.log(`[Expediting Trigger] HOA Required for Opportunity: ${opportunityId}`);

  const result = {
    case: null,
    error: null,
  };

  if (!autoCreateCase) {
    // Case creation is handled by frontend modal - just log
    console.log(`[Expediting Trigger] HOA Required detected - case creation delegated to user`);
    return result;
  }

  try {
    const caseResult = await createExpeditingCase(
      opportunityId,
      CASE_SUBJECTS.HOA,
      'This job requires HOA approval before installation can proceed. Please obtain HOA approval documentation and upload to the job record.',
      CASE_TYPES.HOA,
      null, // No auto-assignment for HOA - user selects in modal
      userId
    );

    result.case = caseResult.case;
    result.wasExisting = caseResult.existing;

    return result;
  } catch (error) {
    console.error('[Expediting Trigger] onHoaRequired failed:', error);
    result.error = error.message;
    return result;
  }
}

// ============================================================================
// TRIGGER 5: HOA Case Closed
// When an HOA case is closed/resolved, auto-set hoaApproved on opportunity
// ============================================================================

/**
 * Trigger: HOA Case Closed
 * When an HOA-type case is closed, automatically set hoaApproved=true
 * on the related opportunity
 */
export async function onHoaCaseClosed(caseId, userId) {
  console.log(`[Expediting Trigger] HOA Case Closed: ${caseId}`);

  const result = {
    opportunityUpdated: false,
    opportunityId: null,
    error: null,
  };

  try {
    // Get the case with its related opportunity
    const closedCase = await prisma.case.findUnique({
      where: { id: caseId },
      include: {
        account: {
          include: {
            opportunities: {
              where: {
                status: { not: 'CLOSED_LOST' },
                hoaRequired: 'yes',
                hoaApproved: false,
              },
              orderBy: { createdAt: 'desc' },
              take: 1,
            },
          },
        },
      },
    });

    if (!closedCase) {
      throw new Error(`Case not found: ${caseId}`);
    }

    // Check if this is an HOA-related case
    const isHoaCase =
      closedCase.type === CASE_TYPES.HOA ||
      closedCase.subject?.toLowerCase().includes('hoa') ||
      closedCase.description?.toLowerCase().includes('hoa approval');

    if (!isHoaCase) {
      console.log(`[Expediting Trigger] Case ${caseId} is not HOA-related, skipping`);
      return result;
    }

    // Find related opportunity
    const opportunity = closedCase.account?.opportunities?.[0];

    if (!opportunity) {
      console.log(`[Expediting Trigger] No eligible opportunity found for HOA approval update`);
      return result;
    }

    // Update the opportunity's hoaApproved field
    await prisma.opportunity.update({
      where: { id: opportunity.id },
      data: {
        hoaApproved: true,
      },
    });

    console.log(`[Expediting Trigger] Set hoaApproved=true for opportunity ${opportunity.id}`);

    // Create activity log
    await prisma.activity.create({
      data: {
        type: 'FIELD_CHANGE',
        subject: 'HOA Approved (Auto-Updated)',
        body: `HOA Approved automatically set to true when HOA case ${closedCase.caseNumber} was closed.`,
        status: 'COMPLETED',
        opportunityId: opportunity.id,
        accountId: closedCase.accountId,
        userId: userId,
        occurredAt: new Date(),
        metadata: {
          triggeredBy: 'expediting_workflow',
          autoGenerated: true,
          reason: 'hoa_case_closed',
          caseId: caseId,
          caseNumber: closedCase.caseNumber,
        },
      },
    });

    result.opportunityUpdated = true;
    result.opportunityId = opportunity.id;

    return result;
  } catch (error) {
    console.error('[Expediting Trigger] onHoaCaseClosed failed:', error);
    result.error = error.message;
    return result;
  }
}

// ============================================================================
// EVALUATE ALL EXPEDITING TRIGGERS
// Called when opportunity expediting fields change
// ============================================================================

/**
 * Evaluate all expediting triggers based on field changes
 * @param {string} opportunityId - The opportunity ID
 * @param {Object} changes - Object containing changed field values
 * @param {Object} previousValues - Object containing previous field values
 * @param {string} userId - User who made the changes
 */
export async function evaluateExpeditingTriggers(opportunityId, changes, previousValues, userId) {
  console.log(`[Expediting Triggers] Evaluating triggers for ${opportunityId}`, { changes });

  const results = {
    flatRoof: null,
    lineDrop: null,
    supplementHold: null,
    hoaRequired: null,
  };

  // Check Flat Roof trigger
  if (changes.flatRoof === true && previousValues?.flatRoof !== true) {
    results.flatRoof = await onFlatRoofDetected(opportunityId, userId);
  }

  // Check Line Drop trigger
  if (changes.lineDrop === true && previousValues?.lineDrop !== true) {
    results.lineDrop = await onLineDropRequired(opportunityId, userId);
  }

  // Check Supplement Holds Job trigger
  if (
    (changes.supplementHoldsJob === true && changes.supplementRequired === true) ||
    (changes.supplementHoldsJob === true && previousValues?.supplementRequired === true) ||
    (changes.supplementRequired === true && previousValues?.supplementHoldsJob === true)
  ) {
    results.supplementHold = await onSupplementHoldsJob(opportunityId, userId);
  }

  // Check HOA Required trigger (logs only, case creation via frontend modal)
  if (changes.hoaRequired === 'yes' && previousValues?.hoaRequired !== 'yes') {
    results.hoaRequired = await onHoaRequired(opportunityId, userId, false);
  }

  return results;
}

export default {
  onFlatRoofDetected,
  onLineDropRequired,
  onSupplementHoldsJob,
  onHoaRequired,
  onHoaCaseClosed,
  evaluateExpeditingTriggers,
};
