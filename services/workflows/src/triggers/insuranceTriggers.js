/**
 * Insurance Workflow Triggers
 *
 * Handles automations for insurance sales workflow:
 * - Post-adjuster meeting actions (task, note, service appointment)
 * - Claim status changes
 * - Supplement approval
 * - Insurance approval
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Insurance opportunity stages/statuses that trigger automations
const INSURANCE_STAGES = {
  ADJUSTER_MEETING_COMPLETE: 'Adjuster Meeting Complete',
  APPROVED: 'Approved',
  CONTRACT_SIGNED: 'Contract Signed',
  SUPPLEMENT_APPROVED: 'Supplement Approved',
};

/**
 * Trigger: Post-Adjuster Meeting Workflow
 * When an insurance opportunity's status changes to "Adjuster Meeting Complete"
 *
 * Actions:
 * 1. Create task: "Prepare specs for this account"
 * 2. Create note: "Are you ready to begin preparing the project specs?"
 * 3. Create service appointment for "Contract Signing"
 */
export async function onAdjusterMeetingComplete(opportunityId, userId) {
  console.log(`[Insurance Trigger] Adjuster Meeting Complete for Opportunity: ${opportunityId}`);

  const results = {
    task: null,
    note: null,
    serviceAppointment: null,
    errors: [],
  };

  try {
    // Get opportunity details
    const opportunity = await prisma.opportunity.findUnique({
      where: { id: opportunityId },
      include: {
        account: true,
        contact: true,
      },
    });

    if (!opportunity) {
      throw new Error(`Opportunity not found: ${opportunityId}`);
    }

    // 1. Create Task: "Prepare specs for this account"
    try {
      const task = await prisma.task.create({
        data: {
          subject: 'Prepare specs for this account',
          description: `Prepare project specifications for ${opportunity.name}.\n\nThis task was auto-generated after the adjuster meeting was completed.`,
          status: 'NOT_STARTED',
          priority: 'HIGH',
          dueDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now
          opportunityId: opportunityId,
          assignedToId: opportunity.ownerId || userId,
        },
      });
      results.task = task;
      console.log(`[Insurance Trigger] Created task: ${task.id}`);
    } catch (taskError) {
      console.error('[Insurance Trigger] Failed to create task:', taskError);
      results.errors.push({ type: 'task', error: taskError.message });
    }

    // 2. Create Note/Activity: "Are you ready to begin preparing the project specs?"
    try {
      const note = await prisma.activity.create({
        data: {
          type: 'NOTE_ADDED',
          subject: 'Project Specs Reminder',
          body: `Are you ready to begin preparing the project specs?\n\nThe adjuster meeting for ${opportunity.name} has been completed. Please proceed with spec preparation.`,
          status: 'COMPLETED',
          opportunityId: opportunityId,
          accountId: opportunity.accountId,
          contactId: opportunity.contactId,
          userId: opportunity.ownerId || userId,
          occurredAt: new Date(),
          metadata: {
            triggeredBy: 'adjuster_meeting_complete',
            autoGenerated: true,
          },
        },
      });
      results.note = note;
      console.log(`[Insurance Trigger] Created note: ${note.id}`);
    } catch (noteError) {
      console.error('[Insurance Trigger] Failed to create note:', noteError);
      results.errors.push({ type: 'note', error: noteError.message });
    }

    // 3. Create Service Appointment for "Contract Signing"
    try {
      // First, find or create a work order for this opportunity
      let workOrder = await prisma.workOrder.findFirst({
        where: { opportunityId: opportunityId },
      });

      if (!workOrder) {
        // Create a work order
        workOrder = await prisma.workOrder.create({
          data: {
            opportunityId: opportunityId,
            accountId: opportunity.accountId,
            subject: `Work Order - ${opportunity.name}`,
            status: 'NEW',
            priority: 'NORMAL',
            street: opportunity.account?.billingStreet,
            city: opportunity.account?.billingCity,
            state: opportunity.account?.billingState,
            postalCode: opportunity.account?.billingPostalCode,
            country: opportunity.account?.billingCountry,
          },
        });
        console.log(`[Insurance Trigger] Created work order: ${workOrder.id}`);
      }

      // Find the "Contract Signing" work type
      let workType = await prisma.workType.findFirst({
        where: {
          OR: [
            { name: { contains: 'Contract Signing', mode: 'insensitive' } },
            { name: { contains: 'Contract', mode: 'insensitive' } },
          ],
        },
      });

      // Create service appointment
      const scheduledStart = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000); // 3 days from now
      const scheduledEnd = new Date(scheduledStart.getTime() + 60 * 60 * 1000); // 1 hour duration

      const serviceAppointment = await prisma.serviceAppointment.create({
        data: {
          workOrderId: workOrder.id,
          workTypeId: workType?.id,
          subject: `Contract Signing - ${opportunity.name}`,
          description: 'Schedule contract signing with homeowner.',
          status: 'NONE',
          street: opportunity.account?.billingStreet,
          city: opportunity.account?.billingCity,
          state: opportunity.account?.billingState,
          postalCode: opportunity.account?.billingPostalCode,
          country: opportunity.account?.billingCountry,
          earliestStartDate: new Date(),
          dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
          duration: 60, // minutes
        },
      });
      results.serviceAppointment = serviceAppointment;
      console.log(`[Insurance Trigger] Created service appointment: ${serviceAppointment.id}`);
    } catch (appointmentError) {
      console.error('[Insurance Trigger] Failed to create service appointment:', appointmentError);
      results.errors.push({ type: 'serviceAppointment', error: appointmentError.message });
    }

    return results;
  } catch (error) {
    console.error('[Insurance Trigger] onAdjusterMeetingComplete failed:', error);
    throw error;
  }
}

/**
 * Trigger: Insurance Approval
 * When an insurance opportunity is marked as approved
 *
 * Actions:
 * 1. Update opportunity stage
 * 2. Create activity log
 * 3. Notify rep
 */
export async function onInsuranceApproved(opportunityId, approvalData, userId) {
  console.log(`[Insurance Trigger] Insurance Approved for Opportunity: ${opportunityId}`);

  try {
    const opportunity = await prisma.opportunity.findUnique({
      where: { id: opportunityId },
      include: { account: true, owner: true },
    });

    if (!opportunity) {
      throw new Error(`Opportunity not found: ${opportunityId}`);
    }

    // Update opportunity with approval info
    const updatedOpportunity = await prisma.opportunity.update({
      where: { id: opportunityId },
      data: {
        isApproved: true,
        stageName: INSURANCE_STAGES.APPROVED,
        rcvAmount: approvalData.rcvAmount,
        acvAmount: approvalData.acvAmount,
        deductible: approvalData.deductible,
        updatedAt: new Date(),
      },
    });

    // Create activity log
    await prisma.activity.create({
      data: {
        type: 'STATUS_CHANGED',
        subject: 'Insurance Claim Approved',
        body: `Insurance claim approved.\nRCV: $${approvalData.rcvAmount?.toFixed(2) || 'N/A'}\nACV: $${approvalData.acvAmount?.toFixed(2) || 'N/A'}\nDeductible: $${approvalData.deductible?.toFixed(2) || 'N/A'}`,
        status: 'COMPLETED',
        opportunityId: opportunityId,
        accountId: opportunity.accountId,
        userId: userId,
        occurredAt: new Date(),
        metadata: {
          triggeredBy: 'insurance_approved',
          approvalData,
        },
      },
    });

    return updatedOpportunity;
  } catch (error) {
    console.error('[Insurance Trigger] onInsuranceApproved failed:', error);
    throw error;
  }
}

/**
 * Trigger: Supplement Requested
 * When a supplement is requested for a service contract
 */
export async function onSupplementRequested(serviceContractId, supplementData, userId) {
  console.log(`[Insurance Trigger] Supplement Requested for Service Contract: ${serviceContractId}`);

  try {
    const serviceContract = await prisma.serviceContract.findUnique({
      where: { id: serviceContractId },
      include: {
        opportunity: { include: { account: true } },
      },
    });

    if (!serviceContract) {
      throw new Error(`Service Contract not found: ${serviceContractId}`);
    }

    // Create task for supplement review
    const task = await prisma.task.create({
      data: {
        subject: `Review Supplement Request - ${serviceContract.name}`,
        description: `Supplement requested for ${serviceContract.name}.\n\nAmount: $${supplementData.amount?.toFixed(2) || 'TBD'}\nReason: ${supplementData.reason || 'Not specified'}`,
        status: 'NOT_STARTED',
        priority: 'HIGH',
        dueDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),
        opportunityId: serviceContract.opportunityId,
        assignedToId: serviceContract.opportunity?.ownerId || userId,
      },
    });

    // Create activity log
    await prisma.activity.create({
      data: {
        type: 'WORKFLOW_TRIGGERED',
        subject: 'Supplement Requested',
        body: `Supplement requested for ${serviceContract.name}.\nAmount: $${supplementData.amount?.toFixed(2) || 'TBD'}\nReason: ${supplementData.reason || 'Not specified'}`,
        status: 'COMPLETED',
        opportunityId: serviceContract.opportunityId,
        accountId: serviceContract.opportunity?.accountId,
        userId: userId,
        occurredAt: new Date(),
        metadata: {
          triggeredBy: 'supplement_requested',
          supplementData,
          serviceContractId,
        },
      },
    });

    return { task };
  } catch (error) {
    console.error('[Insurance Trigger] onSupplementRequested failed:', error);
    throw error;
  }
}

/**
 * Trigger: Supplement Approved
 * When a supplement is approved
 *
 * This integrates with commissionTriggers for supplement commissions
 */
export async function onSupplementApproved(serviceContractId, supplementData, userId) {
  console.log(`[Insurance Trigger] Supplement Approved for Service Contract: ${serviceContractId}`);

  try {
    const serviceContract = await prisma.serviceContract.findUnique({
      where: { id: serviceContractId },
      include: {
        opportunity: { include: { account: true, owner: true } },
      },
    });

    if (!serviceContract) {
      throw new Error(`Service Contract not found: ${serviceContractId}`);
    }

    // Update service contract with supplement total
    const currentSupplements = serviceContract.supplementsClosedTotal || 0;
    const newSupplementsTotal = currentSupplements + (supplementData.amount || 0);

    await prisma.serviceContract.update({
      where: { id: serviceContractId },
      data: {
        supplementsClosedTotal: newSupplementsTotal,
        supplementsCommissionable: supplementData.commissionable !== false,
        updatedAt: new Date(),
      },
    });

    // Create activity log
    await prisma.activity.create({
      data: {
        type: 'WORKFLOW_TRIGGERED',
        subject: 'Supplement Approved',
        body: `Supplement approved for ${serviceContract.name}.\nAmount: $${supplementData.amount?.toFixed(2)}\nNew Total Supplements: $${newSupplementsTotal.toFixed(2)}`,
        status: 'COMPLETED',
        opportunityId: serviceContract.opportunityId,
        accountId: serviceContract.opportunity?.accountId,
        userId: userId,
        occurredAt: new Date(),
        metadata: {
          triggeredBy: 'supplement_approved',
          supplementData,
          serviceContractId,
          previousTotal: currentSupplements,
          newTotal: newSupplementsTotal,
        },
      },
    });

    // Note: Commission creation is handled by commissionTriggers.onSupplementApproved
    // which should be called separately or integrated

    return {
      serviceContractId,
      newSupplementsTotal,
      supplementData
    };
  } catch (error) {
    console.error('[Insurance Trigger] onSupplementApproved failed:', error);
    throw error;
  }
}

/**
 * Trigger: Claim Filed
 * When an insurance claim is filed for an opportunity
 */
export async function onClaimFiled(opportunityId, claimData, userId) {
  console.log(`[Insurance Trigger] Claim Filed for Opportunity: ${opportunityId}`);

  try {
    // Update opportunity with claim info
    const opportunity = await prisma.opportunity.update({
      where: { id: opportunityId },
      data: {
        claimNumber: claimData.claimNumber,
        claimFiledDate: claimData.filedDate || new Date(),
        insuranceCarrier: claimData.insuranceCarrier,
        isPandaClaims: claimData.isPandaClaims || false,
        type: 'INSURANCE',
        updatedAt: new Date(),
      },
      include: { account: true },
    });

    // Create activity log
    await prisma.activity.create({
      data: {
        type: 'WORKFLOW_TRIGGERED',
        subject: 'Insurance Claim Filed',
        body: `Insurance claim filed.\nClaim #: ${claimData.claimNumber || 'Pending'}\nCarrier: ${claimData.insuranceCarrier || 'N/A'}`,
        status: 'COMPLETED',
        opportunityId: opportunityId,
        accountId: opportunity.accountId,
        userId: userId,
        occurredAt: new Date(),
        metadata: {
          triggeredBy: 'claim_filed',
          claimData,
        },
      },
    });

    return opportunity;
  } catch (error) {
    console.error('[Insurance Trigger] onClaimFiled failed:', error);
    throw error;
  }
}

/**
 * Main handler to evaluate and execute insurance triggers based on opportunity changes
 */
export async function evaluateInsuranceTriggers(opportunityId, changes, userId) {
  const results = [];

  // Check for adjuster meeting completion
  if (changes.stageName === INSURANCE_STAGES.ADJUSTER_MEETING_COMPLETE ||
      changes.status === INSURANCE_STAGES.ADJUSTER_MEETING_COMPLETE) {
    const result = await onAdjusterMeetingComplete(opportunityId, userId);
    results.push({ trigger: 'adjusterMeetingComplete', result });
  }

  // Check for insurance approval
  if (changes.isApproved === true || changes.stageName === INSURANCE_STAGES.APPROVED) {
    const result = await onInsuranceApproved(opportunityId, {
      rcvAmount: changes.rcvAmount,
      acvAmount: changes.acvAmount,
      deductible: changes.deductible,
    }, userId);
    results.push({ trigger: 'insuranceApproved', result });
  }

  // Check for claim filed
  if (changes.claimNumber && !changes._previousClaimNumber) {
    const result = await onClaimFiled(opportunityId, {
      claimNumber: changes.claimNumber,
      insuranceCarrier: changes.insuranceCarrier,
      filedDate: changes.claimFiledDate,
      isPandaClaims: changes.isPandaClaims,
    }, userId);
    results.push({ trigger: 'claimFiled', result });
  }

  return results;
}

export default {
  onAdjusterMeetingComplete,
  onInsuranceApproved,
  onSupplementRequested,
  onSupplementApproved,
  onClaimFiled,
  evaluateInsuranceTriggers,
  INSURANCE_STAGES,
};
