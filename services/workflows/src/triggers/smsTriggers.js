/**
 * SMS Workflow Triggers
 *
 * Replicates Salesforce Riley SMS Flows in Panda CRM
 * These triggers send automated SMS notifications for various workflow events.
 *
 * Flows Replicated:
 * 1. Send_SMS_when_Lead_Assigned - Event creation (Inspection/Retail Demo)
 * 2. SMS_Appt_Canceled - Opportunity status change from Confirmed to Canceled
 * 3. Send_SMS_When_WorkOrder_InProgress - WorkOrder status changes to In Progress
 * 4. Send_SMS_WorkOrder_Inspection_Completion - Decking inspection pass/fail, work completed
 * 5. Send_SMS_Crew_Lead_Welcome_Text - Crew lead assigned to scheduled work order
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Bamboogli service URL for sending SMS
const BAMBOOGLI_SERVICE_URL = process.env.BAMBOOGLI_SERVICE_URL || 'http://bamboogli-service:3012';

// Panda Exteriors internal account ID for employee contact lookups
const PANDA_INTERNAL_ACCOUNT_ID = process.env.PANDA_INTERNAL_ACCOUNT_ID;

/**
 * Helper: Get phone number from contact (priority: rileyNumber > mobilePhone > phone)
 */
function getPhoneNumber(contact) {
  if (!contact) return null;
  return contact.rileyNumber || contact.mobilePhone || contact.phone || null;
}

/**
 * Helper: Send SMS via Bamboogli service
 * @param {Object} params
 * @param {string} params.to - Phone number in E.164 format
 * @param {string} params.message - SMS message body
 * @param {string} params.contactId - Contact ID for logging
 * @param {string} params.accountId - Account ID for logging
 * @param {string} params.opportunityId - Opportunity ID for logging
 * @param {string} params.workOrderId - Work Order ID for logging
 */
async function sendSms({ to, message, contactId, accountId, opportunityId, workOrderId }) {
  try {
    // Format phone number to E.164 if needed
    let formattedPhone = to;
    if (to && !to.startsWith('+')) {
      // Remove non-digits
      const digits = to.replace(/\D/g, '');
      // Add +1 for US numbers
      if (digits.length === 10) {
        formattedPhone = `+1${digits}`;
      } else if (digits.length === 11 && digits.startsWith('1')) {
        formattedPhone = `+${digits}`;
      }
    }

    if (!formattedPhone) {
      console.warn('[SMS Trigger] No phone number provided');
      return { success: false, error: 'No phone number provided' };
    }

    console.log(`[SMS Trigger] Sending SMS to ${formattedPhone}`);

    // Call Bamboogli service to send SMS
    const response = await fetch(`${BAMBOOGLI_SERVICE_URL}/api/messages/send`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        to: formattedPhone,
        body: message,
        channel: 'SMS',
        metadata: {
          contactId,
          accountId,
          opportunityId,
          workOrderId,
          triggeredBy: 'smsTriggers',
          autoGenerated: true,
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('[SMS Trigger] Failed to send SMS:', errorText);
      return { success: false, error: errorText };
    }

    const result = await response.json();
    console.log('[SMS Trigger] SMS sent successfully:', result);

    // Log activity
    await prisma.activity.create({
      data: {
        type: 'SMS_SENT',
        subType: 'OUTBOUND',
        subject: 'Automated SMS Sent',
        body: message,
        status: 'COMPLETED',
        contactId,
        accountId,
        opportunityId,
        occurredAt: new Date(),
        metadata: {
          phone: formattedPhone,
          triggeredBy: 'smsTriggers',
          autoGenerated: true,
          twilioSid: result?.data?.twilioSid,
        },
      },
    });

    return { success: true, result };
  } catch (error) {
    console.error('[SMS Trigger] Error sending SMS:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Helper: Find employee contact by user email from internal Panda account
 */
async function findEmployeeContact(userEmail) {
  if (!userEmail) return null;

  try {
    const contact = await prisma.contact.findFirst({
      where: {
        email: userEmail,
        ...(PANDA_INTERNAL_ACCOUNT_ID && { accountId: PANDA_INTERNAL_ACCOUNT_ID }),
      },
    });
    return contact;
  } catch (error) {
    console.error('[SMS Trigger] Error finding employee contact:', error);
    return null;
  }
}

// ============================================================================
// TRIGGER 1: Lead Assigned SMS
// Salesforce Flow: Send_SMS_when_Lead_Assigned
// Trigger: Event created with subject containing "Inspection" or "Retail Demo"
// Recipient: Opportunity owner (sales rep)
// ============================================================================

/**
 * Send SMS to sales rep when new lead is assigned (inspection or retail demo scheduled)
 * @param {string} eventId - Service appointment or event ID
 * @param {Object} eventData - Event data with subject, startTime, opportunityId
 */
export async function onLeadAssigned(eventId, eventData) {
  console.log(`[SMS Trigger] Lead Assigned event: ${eventId}`);

  try {
    const { subject, startDateTime, opportunityId } = eventData;

    // Check if this is an inspection or retail demo
    const subjectLower = (subject || '').toLowerCase();
    if (!subjectLower.includes('inspection') && !subjectLower.includes('retail demo')) {
      console.log('[SMS Trigger] Skipping - not an inspection or retail demo');
      return null;
    }

    // Get opportunity with account and owner
    const opportunity = await prisma.opportunity.findUnique({
      where: { id: opportunityId },
      include: {
        account: true,
        owner: true,
      },
    });

    if (!opportunity) {
      console.error('[SMS Trigger] Opportunity not found:', opportunityId);
      return null;
    }

    // Find the owner's contact record (employee)
    const ownerContact = await findEmployeeContact(opportunity.owner?.email);
    if (!ownerContact) {
      console.log('[SMS Trigger] Owner contact not found, skipping SMS');
      return null;
    }

    const phoneNumber = getPhoneNumber(ownerContact);
    if (!phoneNumber) {
      console.log('[SMS Trigger] No phone number for owner, skipping SMS');
      return null;
    }

    // Format the date
    const startDate = new Date(startDateTime);
    const dateStr = `${startDate.getMonth() + 1}/${startDate.getDate()}`;

    // Build address
    const address = [
      opportunity.account?.billingStreet,
      opportunity.account?.billingCity,
    ].filter(Boolean).join(', ');

    // Build message (matches Salesforce flow)
    const message = `New Lead Assigned: ${opportunity.name} for ${dateStr} at ${address}`;

    return await sendSms({
      to: phoneNumber,
      message,
      contactId: ownerContact.id,
      opportunityId: opportunity.id,
      accountId: opportunity.accountId,
    });
  } catch (error) {
    console.error('[SMS Trigger] onLeadAssigned failed:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// TRIGGER 2: Appointment Canceled SMS
// Salesforce Flow: SMS_Appt_Canceled
// Trigger: Opportunity Status__c changes from "Confirmed" to "Canceled"
// Recipient: Prior owner (the sales rep who had the appointment)
// ============================================================================

/**
 * Send SMS to sales rep when appointment is canceled
 * @param {string} opportunityId
 * @param {Object} changes - Changes object with previousStatus
 */
export async function onAppointmentCanceled(opportunityId, changes) {
  console.log(`[SMS Trigger] Appointment Canceled for opportunity: ${opportunityId}`);

  try {
    const { previousStatus, previousOwnerId } = changes;

    // Only trigger if status changed from Confirmed to Canceled
    if (previousStatus?.toLowerCase() !== 'confirmed') {
      console.log('[SMS Trigger] Previous status was not Confirmed, skipping');
      return null;
    }

    const opportunity = await prisma.opportunity.findUnique({
      where: { id: opportunityId },
      include: { account: true },
    });

    if (!opportunity) {
      console.error('[SMS Trigger] Opportunity not found');
      return null;
    }

    // Get the prior owner's user record
    const priorOwnerId = previousOwnerId || opportunity.ownerId;
    const priorOwner = await prisma.user.findUnique({
      where: { id: priorOwnerId },
    });

    if (!priorOwner) {
      console.log('[SMS Trigger] Prior owner not found');
      return null;
    }

    // Find the owner's contact record
    const ownerContact = await findEmployeeContact(priorOwner.email);
    if (!ownerContact) {
      console.log('[SMS Trigger] Owner contact not found');
      return null;
    }

    const phoneNumber = getPhoneNumber(ownerContact);
    if (!phoneNumber) {
      console.log('[SMS Trigger] No phone number for owner');
      return null;
    }

    // Format appointment time
    let apptTimeStr = '';
    if (opportunity.tentativeAppointmentDate) {
      const apptDate = new Date(opportunity.tentativeAppointmentDate);
      const dateStr = apptDate.toLocaleDateString();
      const hours = apptDate.getHours();
      const minutes = apptDate.getMinutes().toString().padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const hour12 = hours % 12 || 12;
      apptTimeStr = `${dateStr} ${hour12}:${minutes} ${ampm}`;
    }

    // Build message (matches Salesforce flow)
    const message = `APPT CANCELED: the appointment for ${opportunity.name} at ${apptTimeStr} has been canceled and removed from your calendar`;

    return await sendSms({
      to: phoneNumber,
      message,
      contactId: ownerContact.id,
      opportunityId: opportunity.id,
      accountId: opportunity.accountId,
    });
  } catch (error) {
    console.error('[SMS Trigger] onAppointmentCanceled failed:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// TRIGGER 3: WorkOrder In Progress SMS
// Salesforce Flow: Send_SMS_When_WorkOrder_InProgress
// Trigger: WorkOrder status changes to "In Progress"
// Recipient: Customer contact
// ============================================================================

/**
 * Send SMS to customer when work order status changes to In Progress
 * @param {string} workOrderId
 * @param {string} previousStatus
 */
export async function onWorkOrderInProgress(workOrderId, previousStatus) {
  console.log(`[SMS Trigger] WorkOrder In Progress: ${workOrderId}`);

  try {
    // Only trigger if status actually changed to In Progress
    if (previousStatus?.toLowerCase() === 'in progress') {
      console.log('[SMS Trigger] Status was already In Progress, skipping');
      return null;
    }

    const workOrder = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
      include: {
        account: {
          include: {
            projectManager: true,
          },
        },
        contact: true,
        opportunity: {
          include: {
            contact: true,
          },
        },
      },
    });

    if (!workOrder) {
      console.error('[SMS Trigger] WorkOrder not found');
      return null;
    }

    // Get customer contact (from work order or opportunity)
    const customerContact = workOrder.contact || workOrder.opportunity?.contact;
    if (!customerContact) {
      console.log('[SMS Trigger] No customer contact found');
      return null;
    }

    const phoneNumber = getPhoneNumber(customerContact);
    if (!phoneNumber) {
      console.log('[SMS Trigger] No phone number for customer');
      return null;
    }

    // Get project manager name
    const pmFirstName = workOrder.account?.projectManager?.firstName || 'Your project manager';

    // Build message (matches Salesforce flow)
    const message = `Hello this is ${pmFirstName} with Panda Exteriors. The crew has arrived and the tear off will begin shortly. We will update you after our inspection of your roof decking.`;

    return await sendSms({
      to: phoneNumber,
      message,
      contactId: customerContact.id,
      workOrderId: workOrder.id,
      accountId: workOrder.accountId,
    });
  } catch (error) {
    console.error('[SMS Trigger] onWorkOrderInProgress failed:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// TRIGGER 4: WorkOrder Inspection/Completion SMS
// Salesforce Flow: Send_SMS_WorkOrder_Inspection_Completion
// Triggers:
//   - Work_Completed__c = "Yes" -> Completion message
//   - Decking_Inspection__c = "Pass" -> Decking pass message
//   - Decking_Inspection__c = "Fail" -> Decking fail message
// Recipient: Customer contact
// ============================================================================

// SMS message templates
const SMS_MESSAGES = {
  COMPLETION: 'Congratulations! Your roofing project has been completed. Should you have any concerns regarding your installation, please don\'t hesitate to reach out to me. The billing department will handle the close out & warranty submission of your project.',
  DECKING_PASS: 'Update on your roofing project: The decking inspection has passed and the crew is moving forward with the installation of the new roof.',
  DECKING_FAIL: 'Update on your roofing project: The decking inspection has failed and the crew is on standby. We will be sending a photo report and calling you shortly to resolve this matter.',
};

/**
 * Send SMS when work is completed
 * @param {string} workOrderId
 */
export async function onWorkCompleted(workOrderId) {
  console.log(`[SMS Trigger] Work Completed: ${workOrderId}`);
  return await sendWorkOrderSms(workOrderId, SMS_MESSAGES.COMPLETION, 'work_completed');
}

/**
 * Send SMS when decking inspection passes
 * @param {string} workOrderId
 */
export async function onDeckingInspectionPass(workOrderId) {
  console.log(`[SMS Trigger] Decking Inspection Pass: ${workOrderId}`);
  return await sendWorkOrderSms(workOrderId, SMS_MESSAGES.DECKING_PASS, 'decking_pass');
}

/**
 * Send SMS when decking inspection fails
 * @param {string} workOrderId
 */
export async function onDeckingInspectionFail(workOrderId) {
  console.log(`[SMS Trigger] Decking Inspection Fail: ${workOrderId}`);
  return await sendWorkOrderSms(workOrderId, SMS_MESSAGES.DECKING_FAIL, 'decking_fail');
}

/**
 * Helper: Send work order related SMS to customer
 */
async function sendWorkOrderSms(workOrderId, message, triggerType) {
  try {
    const workOrder = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
      include: {
        contact: true,
        opportunity: {
          include: { contact: true },
        },
      },
    });

    if (!workOrder) {
      console.error('[SMS Trigger] WorkOrder not found');
      return null;
    }

    // Get customer contact
    const customerContact = workOrder.contact || workOrder.opportunity?.contact;
    if (!customerContact) {
      console.log('[SMS Trigger] No customer contact found');
      return null;
    }

    const phoneNumber = getPhoneNumber(customerContact);
    if (!phoneNumber) {
      console.log('[SMS Trigger] No phone number for customer');
      return null;
    }

    return await sendSms({
      to: phoneNumber,
      message,
      contactId: customerContact.id,
      workOrderId: workOrder.id,
      accountId: workOrder.accountId,
    });
  } catch (error) {
    console.error(`[SMS Trigger] sendWorkOrderSms (${triggerType}) failed:`, error);
    return { success: false, error: error.message };
  }
}

/**
 * Evaluate work order inspection/completion triggers
 * @param {string} workOrderId
 * @param {Object} changes - Field changes
 * @param {Object} previousValues - Previous field values
 */
export async function evaluateWorkOrderInspectionTriggers(workOrderId, changes, previousValues) {
  const results = [];

  // Check Work Completed
  if (changes.workCompleted === 'Yes' && previousValues.workCompleted !== 'Yes') {
    const result = await onWorkCompleted(workOrderId);
    results.push({ trigger: 'workCompleted', result });
  }

  // Check Decking Inspection Pass
  if (changes.deckingInspection === 'Pass' && previousValues.deckingInspection !== 'Pass') {
    const result = await onDeckingInspectionPass(workOrderId);
    results.push({ trigger: 'deckingInspectionPass', result });
  }

  // Check Decking Inspection Fail
  if (changes.deckingInspection === 'Fail' && previousValues.deckingInspection !== 'Fail') {
    const result = await onDeckingInspectionFail(workOrderId);
    results.push({ trigger: 'deckingInspectionFail', result });
  }

  return results;
}

// ============================================================================
// TRIGGER 5: Crew Lead Welcome SMS
// Salesforce Flow: Send_SMS_Crew_Lead_Welcome_Text
// Trigger: WorkOrder Crew_Lead_Assigned__c changes AND Status = "Scheduled"
// Recipient: Crew lead contact
// ============================================================================

const CREW_LEAD_WELCOME_MESSAGE = 'Buenos Dias Porfavor hay que verificar las instrucciones y el Material. Porfavor Que todo el equipo ande amarrado y con harness. Me Avisa del Plywood. Porfavor no removamos Plywood hasta que yo le avise. Muchas Gracias';

/**
 * Send welcome SMS to crew lead when assigned to a scheduled work order
 * @param {string} workOrderId
 * @param {string} crewLeadId - Contact ID of the crew lead
 */
export async function onCrewLeadAssigned(workOrderId, crewLeadId) {
  console.log(`[SMS Trigger] Crew Lead Assigned: ${workOrderId}, Crew Lead: ${crewLeadId}`);

  try {
    const workOrder = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
    });

    if (!workOrder) {
      console.error('[SMS Trigger] WorkOrder not found');
      return null;
    }

    // Only send if work order is scheduled
    if (workOrder.status?.toLowerCase() !== 'scheduled') {
      console.log('[SMS Trigger] WorkOrder not scheduled, skipping crew lead SMS');
      return null;
    }

    // Get crew lead contact
    const crewLeadContact = await prisma.contact.findUnique({
      where: { id: crewLeadId },
    });

    if (!crewLeadContact) {
      console.log('[SMS Trigger] Crew lead contact not found');
      return null;
    }

    const phoneNumber = getPhoneNumber(crewLeadContact);
    if (!phoneNumber) {
      console.log('[SMS Trigger] No phone number for crew lead');
      return null;
    }

    return await sendSms({
      to: phoneNumber,
      message: CREW_LEAD_WELCOME_MESSAGE,
      contactId: crewLeadContact.id,
      workOrderId: workOrder.id,
      accountId: workOrder.accountId,
    });
  } catch (error) {
    console.error('[SMS Trigger] onCrewLeadAssigned failed:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Evaluate crew lead assignment trigger
 * @param {string} workOrderId
 * @param {Object} changes - Field changes
 * @param {Object} previousValues - Previous values
 */
export async function evaluateCrewLeadTrigger(workOrderId, changes, previousValues) {
  // Check if crew lead was just assigned
  if (changes.crewLeadId && changes.crewLeadId !== previousValues.crewLeadId) {
    // Check if status is Scheduled
    const workOrder = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
      select: { status: true },
    });

    if (workOrder?.status?.toLowerCase() === 'scheduled') {
      return await onCrewLeadAssigned(workOrderId, changes.crewLeadId);
    }
  }
  return null;
}

// ============================================================================
// Main Evaluation Functions
// ============================================================================

/**
 * Evaluate all SMS triggers for an opportunity update
 * @param {string} opportunityId
 * @param {Object} changes - New values
 * @param {Object} previousValues - Previous values
 */
export async function evaluateOpportunitySMSTriggers(opportunityId, changes, previousValues) {
  const results = [];

  // Check for appointment cancellation
  if (changes.status?.toLowerCase() === 'canceled' &&
      previousValues.status?.toLowerCase() === 'confirmed') {
    const result = await onAppointmentCanceled(opportunityId, {
      previousStatus: previousValues.status,
      previousOwnerId: previousValues.ownerId,
    });
    results.push({ trigger: 'appointmentCanceled', result });
  }

  return results;
}

/**
 * Evaluate all SMS triggers for a work order update
 * @param {string} workOrderId
 * @param {Object} changes - New values
 * @param {Object} previousValues - Previous values
 */
export async function evaluateWorkOrderSMSTriggers(workOrderId, changes, previousValues) {
  const results = [];

  // Check for In Progress status change
  if (changes.status?.toLowerCase() === 'in progress' &&
      previousValues.status?.toLowerCase() !== 'in progress') {
    const result = await onWorkOrderInProgress(workOrderId, previousValues.status);
    results.push({ trigger: 'workOrderInProgress', result });
  }

  // Check inspection/completion triggers
  const inspectionResults = await evaluateWorkOrderInspectionTriggers(workOrderId, changes, previousValues);
  results.push(...inspectionResults);

  // Check crew lead assignment
  const crewLeadResult = await evaluateCrewLeadTrigger(workOrderId, changes, previousValues);
  if (crewLeadResult) {
    results.push({ trigger: 'crewLeadAssigned', result: crewLeadResult });
  }

  return results;
}

// ============================================================================
// TRIGGER: Service Appointment Canceled SMS
// Salesforce Flow: SMS_Appt_Canceled (triggers on SA status change)
// Trigger: ServiceAppointment status changes to "Canceled" from "Scheduled"/"Dispatched"
// Recipient: Assigned resource (the rep/crew who had the appointment)
// ============================================================================

/**
 * Send SMS to assigned resource when service appointment is canceled
 * @param {string} appointmentId
 * @param {Object} changes - Changes object with previousStatus
 */
export async function onServiceAppointmentCanceled(appointmentId, changes) {
  console.log(`[SMS Trigger] Service Appointment Canceled: ${appointmentId}`);

  try {
    const { previousStatus } = changes;

    // Only trigger if status changed from Scheduled or Dispatched to Canceled
    const validPreviousStatuses = ['scheduled', 'dispatched', 'confirmed'];
    if (!validPreviousStatuses.includes(previousStatus?.toLowerCase())) {
      console.log(`[SMS Trigger] Previous status "${previousStatus}" not a valid trigger status, skipping`);
      return null;
    }

    const appointment = await prisma.serviceAppointment.findUnique({
      where: { id: appointmentId },
      include: {
        workOrder: {
          include: {
            opportunity: {
              include: {
                account: true,
                owner: true,
              },
            },
          },
        },
        assignedResources: {
          include: {
            serviceResource: {
              include: {
                user: true,
              },
            },
          },
        },
      },
    });

    if (!appointment) {
      console.error('[SMS Trigger] Service Appointment not found');
      return null;
    }

    // Get opportunity and owner info
    const opportunity = appointment.workOrder?.opportunity;
    if (!opportunity) {
      console.log('[SMS Trigger] No opportunity linked to appointment');
      return null;
    }

    // Try to get phone number from assigned resource first, then fallback to opportunity owner
    let phoneNumber = null;
    let recipientName = '';

    // Check assigned resources
    if (appointment.assignedResources?.length > 0) {
      const assignedResource = appointment.assignedResources[0];
      const resourceUser = assignedResource.serviceResource?.user;
      if (resourceUser) {
        // Find employee contact for assigned resource
        const resourceContact = await findEmployeeContact(resourceUser.email);
        if (resourceContact) {
          phoneNumber = getPhoneNumber(resourceContact);
          recipientName = `${resourceUser.firstName} ${resourceUser.lastName}`;
        }
      }
    }

    // Fallback to opportunity owner
    if (!phoneNumber && opportunity.owner) {
      const ownerContact = await findEmployeeContact(opportunity.owner.email);
      if (ownerContact) {
        phoneNumber = getPhoneNumber(ownerContact);
        recipientName = `${opportunity.owner.firstName} ${opportunity.owner.lastName}`;
      }
    }

    if (!phoneNumber) {
      console.log('[SMS Trigger] No phone number found for recipient');
      return null;
    }

    // Format appointment time
    let apptTimeStr = 'TBD';
    if (appointment.scheduledStart) {
      const apptDate = new Date(appointment.scheduledStart);
      const dateStr = apptDate.toLocaleDateString();
      const hours = apptDate.getHours();
      const minutes = apptDate.getMinutes().toString().padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const hour12 = hours % 12 || 12;
      apptTimeStr = `${dateStr} ${hour12}:${minutes} ${ampm}`;
    }

    // Build message (matches Salesforce SMS_Appt_Canceled flow)
    const message = `APPT CANCELED: ${opportunity.name} at ${apptTimeStr} has been canceled`;

    console.log(`[SMS Trigger] Sending cancellation SMS to ${recipientName} at ${phoneNumber}`);

    return await sendSms({
      to: phoneNumber,
      message,
      contactId: null, // Internal notification
      opportunityId: opportunity.id,
      accountId: opportunity.accountId,
    });
  } catch (error) {
    console.error('[SMS Trigger] onServiceAppointmentCanceled failed:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Evaluate SMS triggers for service appointment changes
 * @param {string} appointmentId
 * @param {Object} appointmentData - Current appointment data
 * @param {Object} previousValues - Previous values before the change
 */
export async function evaluateServiceAppointmentSMSTriggers(appointmentId, appointmentData, previousValues = {}) {
  const results = [];

  // Check for lead assignment (inspection or retail demo) - on creation
  const subject = (appointmentData.subject || '').toLowerCase();
  if (subject.includes('inspection') || subject.includes('retail demo')) {
    // Only trigger if this is a new appointment (no previous status)
    if (!previousValues.status) {
      const result = await onLeadAssigned(appointmentId, {
        subject: appointmentData.subject,
        startDateTime: appointmentData.scheduledStart || appointmentData.earliestStartDate,
        opportunityId: appointmentData.opportunityId || appointmentData.workOrder?.opportunityId,
      });
      results.push({ trigger: 'leadAssigned', result });
    }
  }

  // Check for appointment cancellation
  const currentStatus = (appointmentData.status || '').toLowerCase();
  const previousStatus = (previousValues.status || '').toLowerCase();

  if (currentStatus === 'canceled' && previousStatus !== 'canceled') {
    const result = await onServiceAppointmentCanceled(appointmentId, {
      previousStatus: previousValues.status,
    });
    results.push({ trigger: 'appointmentCanceled', result });
  }

  return results;
}

export default {
  // Individual triggers
  onLeadAssigned,
  onAppointmentCanceled,
  onServiceAppointmentCanceled,
  onWorkOrderInProgress,
  onWorkCompleted,
  onDeckingInspectionPass,
  onDeckingInspectionFail,
  onCrewLeadAssigned,

  // Evaluation functions
  evaluateOpportunitySMSTriggers,
  evaluateWorkOrderSMSTriggers,
  evaluateServiceAppointmentSMSTriggers,
  evaluateWorkOrderInspectionTriggers,
  evaluateCrewLeadTrigger,

  // Message templates (for testing/customization)
  SMS_MESSAGES,
  CREW_LEAD_WELCOME_MESSAGE,
};
