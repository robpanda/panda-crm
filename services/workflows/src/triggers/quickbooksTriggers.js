/**
 * QuickBooks Sync Triggers
 *
 * Automated synchronization between Panda CRM and QuickBooks Online:
 * - Account → QB Customer (on onboarding)
 * - Invoice → QB Invoice (on creation)
 * - Payment → QB Payment (on Stripe webhook)
 *
 * Replaces Salesforce Apex triggers:
 * - AccountStatusDurationTrigger (creates QB customer on "Onboarding")
 * - paymentsTrigger (creates QB payment on "Settled Successfully")
 */

import { PrismaClient } from '@prisma/client';
import { logger } from '../middleware/logger.js';

const prisma = new PrismaClient();

// Payments service URL for QuickBooks API calls
const PAYMENTS_SERVICE_URL = process.env.PAYMENTS_SERVICE_URL || 'http://payments-service:3007';

/**
 * Trigger: Account Status Changed to "Onboarding"
 * Creates QuickBooks Customer from Account
 *
 * Equivalent to: Salesforce AccountStatusDurationTrigger
 *
 * Entry Criteria:
 * - Account.status changes to "Onboarding" OR "ONBOARDING"
 * - Account does not already have a qbCustomerId
 */
export async function onAccountOnboarding(accountId, userId) {
  logger.info(`[QB Trigger] Account onboarding: ${accountId}`);

  const results = {
    qbCustomerCreated: null,
    stripeCustomerCreated: null,
    errors: [],
  };

  try {
    // Get account with primary contact
    const account = await prisma.account.findUnique({
      where: { id: accountId },
      include: {
        contacts: {
          take: 1,
          orderBy: { isPrimary: 'desc' },
        },
      },
    });

    if (!account) {
      throw new Error(`Account not found: ${accountId}`);
    }

    // Skip if already has QB customer
    if (account.qbCustomerId) {
      logger.info(`[QB Trigger] Account ${accountId} already has QB customer: ${account.qbCustomerId}`);
      return results;
    }

    // Create QuickBooks customer via payments service
    try {
      const qbResponse = await fetch(`${PAYMENTS_SERVICE_URL}/api/quickbooks/sync/customer/${accountId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });

      if (qbResponse.ok) {
        const qbResult = await qbResponse.json();
        results.qbCustomerCreated = qbResult.data;
        logger.info(`[QB Trigger] QB Customer created: ${qbResult.data?.qbCustomerId}`);
      } else {
        const error = await qbResponse.text();
        logger.error('[QB Trigger] QB customer creation failed:', error);
        results.errors.push({ type: 'quickbooks', error });
      }
    } catch (qbError) {
      logger.error('[QB Trigger] QB API call failed:', qbError);
      results.errors.push({ type: 'quickbooks_api', error: qbError.message });
    }

    // Also create Stripe customer if not exists
    if (!account.stripeCustomerId) {
      try {
        const stripeResponse = await fetch(`${PAYMENTS_SERVICE_URL}/api/customers/sync/${accountId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });

        if (stripeResponse.ok) {
          const stripeResult = await stripeResponse.json();
          results.stripeCustomerCreated = stripeResult.data;
          logger.info(`[QB Trigger] Stripe Customer created: ${stripeResult.data?.stripeCustomerId}`);
        } else {
          const error = await stripeResponse.text();
          logger.error('[QB Trigger] Stripe customer creation failed:', error);
          results.errors.push({ type: 'stripe', error });
        }
      } catch (stripeError) {
        logger.error('[QB Trigger] Stripe API call failed:', stripeError);
        results.errors.push({ type: 'stripe_api', error: stripeError.message });
      }
    }

    // Create activity log
    try {
      await prisma.activity.create({
        data: {
          type: 'WORKFLOW_TRIGGERED',
          subject: 'Customer Synced to Payment Systems',
          body: `Account "${account.name}" has been synced to QuickBooks${results.qbCustomerCreated ? ` (${results.qbCustomerCreated.qbCustomerId})` : ''} and Stripe${results.stripeCustomerCreated ? ` (${results.stripeCustomerCreated.stripeCustomerId})` : ''} for invoice and payment processing.`,
          status: 'COMPLETED',
          accountId: accountId,
          userId: userId,
          occurredAt: new Date(),
          metadata: {
            triggeredBy: 'account_onboarding',
            autoGenerated: true,
            qbCustomerId: results.qbCustomerCreated?.qbCustomerId,
            stripeCustomerId: results.stripeCustomerCreated?.stripeCustomerId,
          },
        },
      });
    } catch (activityError) {
      logger.error('[QB Trigger] Failed to create activity:', activityError);
      results.errors.push({ type: 'activity', error: activityError.message });
    }

    return results;
  } catch (error) {
    logger.error('[QB Trigger] onAccountOnboarding failed:', error);
    throw error;
  }
}

/**
 * Trigger: Invoice Created
 * Syncs Invoice to QuickBooks
 *
 * Entry Criteria:
 * - Invoice created in Panda CRM
 * - Account has qbCustomerId
 */
export async function onInvoiceCreated(invoiceId, userId) {
  logger.info(`[QB Trigger] Invoice created: ${invoiceId}`);

  const results = {
    qbInvoiceCreated: null,
    stripeInvoiceCreated: null,
    paymentLinkGenerated: null,
    errors: [],
  };

  try {
    const invoice = await prisma.invoice.findUnique({
      where: { id: invoiceId },
      include: {
        account: true,
        lineItems: true,
        opportunity: {
          select: { id: true, name: true },
        },
      },
    });

    if (!invoice) {
      throw new Error(`Invoice not found: ${invoiceId}`);
    }

    // Sync to QuickBooks if account has QB customer
    if (invoice.account?.qbCustomerId && !invoice.qbInvoiceId) {
      try {
        const qbResponse = await fetch(`${PAYMENTS_SERVICE_URL}/api/quickbooks/sync/invoice/${invoiceId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });

        if (qbResponse.ok) {
          const qbResult = await qbResponse.json();
          results.qbInvoiceCreated = qbResult.data;
          logger.info(`[QB Trigger] QB Invoice created: ${qbResult.data?.qbInvoiceId}`);
        } else {
          const error = await qbResponse.text();
          logger.error('[QB Trigger] QB invoice sync failed:', error);
          results.errors.push({ type: 'quickbooks', error });
        }
      } catch (qbError) {
        logger.error('[QB Trigger] QB API call failed:', qbError);
        results.errors.push({ type: 'quickbooks_api', error: qbError.message });
      }
    }

    // Generate Stripe payment link for customer to pay
    if (invoice.account?.stripeCustomerId && !invoice.stripePaymentLinkId) {
      try {
        const paymentLinkResponse = await fetch(`${PAYMENTS_SERVICE_URL}/api/invoices/${invoiceId}/payment-link`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });

        if (paymentLinkResponse.ok) {
          const paymentLinkResult = await paymentLinkResponse.json();
          results.paymentLinkGenerated = paymentLinkResult.data;
          logger.info(`[QB Trigger] Payment link generated: ${paymentLinkResult.data?.url}`);
        } else {
          const error = await paymentLinkResponse.text();
          logger.error('[QB Trigger] Payment link generation failed:', error);
          results.errors.push({ type: 'stripe_payment_link', error });
        }
      } catch (stripeError) {
        logger.error('[QB Trigger] Stripe payment link call failed:', stripeError);
        results.errors.push({ type: 'stripe_api', error: stripeError.message });
      }
    }

    return results;
  } catch (error) {
    logger.error('[QB Trigger] onInvoiceCreated failed:', error);
    throw error;
  }
}

/**
 * Trigger: Payment Received (from Stripe webhook)
 * Records Payment in QuickBooks
 *
 * Equivalent to: Salesforce paymentsTrigger (on "Settled Successfully")
 *
 * Entry Criteria:
 * - Payment status = "SUCCEEDED" or "Settled Successfully"
 * - Account has qbCustomerId
 * - Invoice has qbInvoiceId
 */
export async function onPaymentReceived(paymentId, userId) {
  logger.info(`[QB Trigger] Payment received: ${paymentId}`);

  const results = {
    qbPaymentCreated: null,
    invoiceUpdated: false,
    errors: [],
  };

  try {
    const payment = await prisma.payment.findUnique({
      where: { id: paymentId },
      include: {
        invoice: {
          include: { account: true },
        },
      },
    });

    if (!payment) {
      throw new Error(`Payment not found: ${paymentId}`);
    }

    // Skip if already synced to QB
    if (payment.qbPaymentId) {
      logger.info(`[QB Trigger] Payment ${paymentId} already synced to QB: ${payment.qbPaymentId}`);
      return results;
    }

    // Sync payment to QuickBooks
    if (payment.invoice?.account?.qbCustomerId) {
      try {
        const qbResponse = await fetch(`${PAYMENTS_SERVICE_URL}/api/quickbooks/sync/payment`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            paymentId: paymentId,
            invoiceId: payment.invoiceId,
          }),
        });

        if (qbResponse.ok) {
          const qbResult = await qbResponse.json();
          results.qbPaymentCreated = qbResult.data;
          logger.info(`[QB Trigger] QB Payment created: ${qbResult.data?.qbPaymentId}`);
        } else {
          const error = await qbResponse.text();
          logger.error('[QB Trigger] QB payment sync failed:', error);
          results.errors.push({ type: 'quickbooks', error });
        }
      } catch (qbError) {
        logger.error('[QB Trigger] QB API call failed:', qbError);
        results.errors.push({ type: 'quickbooks_api', error: qbError.message });
      }
    }

    // Update invoice balance
    if (payment.invoiceId) {
      try {
        const invoice = await prisma.invoice.findUnique({
          where: { id: payment.invoiceId },
        });

        if (invoice) {
          const newAmountPaid = parseFloat(invoice.amountPaid || 0) + parseFloat(payment.amount);
          const newBalanceDue = parseFloat(invoice.total) - newAmountPaid;

          await prisma.invoice.update({
            where: { id: payment.invoiceId },
            data: {
              amountPaid: newAmountPaid,
              balanceDue: Math.max(0, newBalanceDue),
              status: newBalanceDue <= 0 ? 'PAID' : invoice.status,
            },
          });

          results.invoiceUpdated = true;
          logger.info(`[QB Trigger] Invoice ${payment.invoiceId} updated - Balance: $${newBalanceDue}`);
        }
      } catch (invoiceError) {
        logger.error('[QB Trigger] Invoice update failed:', invoiceError);
        results.errors.push({ type: 'invoice_update', error: invoiceError.message });
      }
    }

    return results;
  } catch (error) {
    logger.error('[QB Trigger] onPaymentReceived failed:', error);
    throw error;
  }
}

/**
 * Evaluate account status change for QB triggers
 */
export async function evaluateAccountStatusChange(accountId, oldStatus, newStatus, userId) {
  const results = [];

  // Trigger QB customer creation on onboarding
  const onboardingStatuses = ['Onboarding', 'ONBOARDING', 'onboarding'];
  if (onboardingStatuses.includes(newStatus) && !onboardingStatuses.includes(oldStatus)) {
    const result = await onAccountOnboarding(accountId, userId);
    results.push({ trigger: 'accountOnboarding', result });
  }

  return results;
}

export default {
  onAccountOnboarding,
  onInvoiceCreated,
  onPaymentReceived,
  evaluateAccountStatusChange,
};
